// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// clang-format off
// source: svga.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "Svga.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(SVGAProtoAudioEntity);
GPBObjCClassDeclaration(SVGAProtoFrameEntity);
GPBObjCClassDeclaration(SVGAProtoLayout);
GPBObjCClassDeclaration(SVGAProtoMovieEntity);
GPBObjCClassDeclaration(SVGAProtoMovieParams);
GPBObjCClassDeclaration(SVGAProtoShapeEntity);
GPBObjCClassDeclaration(SVGAProtoShapeEntity_EllipseArgs);
GPBObjCClassDeclaration(SVGAProtoShapeEntity_RectArgs);
GPBObjCClassDeclaration(SVGAProtoShapeEntity_ShapeArgs);
GPBObjCClassDeclaration(SVGAProtoShapeEntity_ShapeStyle);
GPBObjCClassDeclaration(SVGAProtoShapeEntity_ShapeStyle_RGBAColor);
GPBObjCClassDeclaration(SVGAProtoSpriteEntity);
GPBObjCClassDeclaration(SVGAProtoTransform);

#pragma mark - SVGAProtoSvgaRoot

@implementation SVGAProtoSvgaRoot

// No extensions in the file and no imports or none of the imports (direct or
// indirect) defined extensions, so no need to generate +extensionRegistry.

@end

static GPBFileDescription SVGAProtoSvgaRoot_FileDescription = {
  .package = "com.opensource.svga",
  .prefix = "SVGAProto",
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - Enum SVGAProtoShapeEntity_ShapeType

GPBEnumDescriptor *SVGAProtoShapeEntity_ShapeType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "Shape\000Rect\000Ellipse\000Keep\000";
    static const int32_t values[] = {
        SVGAProtoShapeEntity_ShapeType_Shape,
        SVGAProtoShapeEntity_ShapeType_Rect,
        SVGAProtoShapeEntity_ShapeType_Ellipse,
        SVGAProtoShapeEntity_ShapeType_Keep,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SVGAProtoShapeEntity_ShapeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SVGAProtoShapeEntity_ShapeType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SVGAProtoShapeEntity_ShapeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SVGAProtoShapeEntity_ShapeType_Shape:
    case SVGAProtoShapeEntity_ShapeType_Rect:
    case SVGAProtoShapeEntity_ShapeType_Ellipse:
    case SVGAProtoShapeEntity_ShapeType_Keep:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SVGAProtoShapeEntity_ShapeStyle_LineCap

GPBEnumDescriptor *SVGAProtoShapeEntity_ShapeStyle_LineCap_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "LineCapButt\000LineCapRound\000LineCapSquare\000";
    static const int32_t values[] = {
        SVGAProtoShapeEntity_ShapeStyle_LineCap_LineCapButt,
        SVGAProtoShapeEntity_ShapeStyle_LineCap_LineCapRound,
        SVGAProtoShapeEntity_ShapeStyle_LineCap_LineCapSquare,
    };
    static const char *extraTextFormatInfo = "\003\000\007\344\000\001\007\345\000\002\007\346\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SVGAProtoShapeEntity_ShapeStyle_LineCap)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SVGAProtoShapeEntity_ShapeStyle_LineCap_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SVGAProtoShapeEntity_ShapeStyle_LineCap_IsValidValue(int32_t value__) {
  switch (value__) {
    case SVGAProtoShapeEntity_ShapeStyle_LineCap_LineCapButt:
    case SVGAProtoShapeEntity_ShapeStyle_LineCap_LineCapRound:
    case SVGAProtoShapeEntity_ShapeStyle_LineCap_LineCapSquare:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SVGAProtoShapeEntity_ShapeStyle_LineJoin

GPBEnumDescriptor *SVGAProtoShapeEntity_ShapeStyle_LineJoin_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "LineJoinMiter\000LineJoinRound\000LineJoinBeve"
        "l\000";
    static const int32_t values[] = {
        SVGAProtoShapeEntity_ShapeStyle_LineJoin_LineJoinMiter,
        SVGAProtoShapeEntity_ShapeStyle_LineJoin_LineJoinRound,
        SVGAProtoShapeEntity_ShapeStyle_LineJoin_LineJoinBevel,
    };
    static const char *extraTextFormatInfo = "\003\000\010\345\000\001\010\345\000\002\010\345\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SVGAProtoShapeEntity_ShapeStyle_LineJoin)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SVGAProtoShapeEntity_ShapeStyle_LineJoin_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SVGAProtoShapeEntity_ShapeStyle_LineJoin_IsValidValue(int32_t value__) {
  switch (value__) {
    case SVGAProtoShapeEntity_ShapeStyle_LineJoin_LineJoinMiter:
    case SVGAProtoShapeEntity_ShapeStyle_LineJoin_LineJoinRound:
    case SVGAProtoShapeEntity_ShapeStyle_LineJoin_LineJoinBevel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SVGAProtoMovieParams

@implementation SVGAProtoMovieParams

@dynamic viewBoxWidth;
@dynamic viewBoxHeight;
@dynamic fps;
@dynamic frames;

typedef struct SVGAProtoMovieParams__storage_ {
  uint32_t _has_storage_[1];
  float viewBoxWidth;
  float viewBoxHeight;
  int32_t fps;
  int32_t frames;
} SVGAProtoMovieParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "viewBoxWidth",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoMovieParams_FieldNumber_ViewBoxWidth,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SVGAProtoMovieParams__storage_, viewBoxWidth),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "viewBoxHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoMovieParams_FieldNumber_ViewBoxHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SVGAProtoMovieParams__storage_, viewBoxHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "fps",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoMovieParams_FieldNumber_Fps,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SVGAProtoMovieParams__storage_, fps),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "frames",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoMovieParams_FieldNumber_Frames,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SVGAProtoMovieParams__storage_, frames),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SVGAProtoMovieParams)
                                   messageName:@"MovieParams"
                               fileDescription:&SVGAProtoSvgaRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SVGAProtoMovieParams__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\014\000\002\r\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SVGAProtoSpriteEntity

@implementation SVGAProtoSpriteEntity

@dynamic imageKey;
@dynamic framesArray, framesArray_Count;
@dynamic matteKey;

typedef struct SVGAProtoSpriteEntity__storage_ {
  uint32_t _has_storage_[1];
  NSString *imageKey;
  NSMutableArray *framesArray;
  NSString *matteKey;
} SVGAProtoSpriteEntity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imageKey",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoSpriteEntity_FieldNumber_ImageKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SVGAProtoSpriteEntity__storage_, imageKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "framesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SVGAProtoFrameEntity),
        .number = SVGAProtoSpriteEntity_FieldNumber_FramesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SVGAProtoSpriteEntity__storage_, framesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "matteKey",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoSpriteEntity_FieldNumber_MatteKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SVGAProtoSpriteEntity__storage_, matteKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SVGAProtoSpriteEntity)
                                   messageName:@"SpriteEntity"
                               fileDescription:&SVGAProtoSvgaRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SVGAProtoSpriteEntity__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\001\010\000\003\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SVGAProtoAudioEntity

@implementation SVGAProtoAudioEntity

@dynamic audioKey;
@dynamic startFrame;
@dynamic endFrame;
@dynamic startTime;
@dynamic totalTime;

typedef struct SVGAProtoAudioEntity__storage_ {
  uint32_t _has_storage_[1];
  int32_t startFrame;
  int32_t endFrame;
  int32_t startTime;
  int32_t totalTime;
  NSString *audioKey;
} SVGAProtoAudioEntity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audioKey",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoAudioEntity_FieldNumber_AudioKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SVGAProtoAudioEntity__storage_, audioKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startFrame",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoAudioEntity_FieldNumber_StartFrame,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SVGAProtoAudioEntity__storage_, startFrame),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "endFrame",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoAudioEntity_FieldNumber_EndFrame,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SVGAProtoAudioEntity__storage_, endFrame),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoAudioEntity_FieldNumber_StartTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SVGAProtoAudioEntity__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "totalTime",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoAudioEntity_FieldNumber_TotalTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SVGAProtoAudioEntity__storage_, totalTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SVGAProtoAudioEntity)
                                   messageName:@"AudioEntity"
                               fileDescription:&SVGAProtoSvgaRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SVGAProtoAudioEntity__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\005\001\010\000\002\n\000\003\010\000\004\t\000\005\t\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SVGAProtoLayout

@implementation SVGAProtoLayout

@dynamic x;
@dynamic y;
@dynamic width;
@dynamic height;

typedef struct SVGAProtoLayout__storage_ {
  uint32_t _has_storage_[1];
  float x;
  float y;
  float width;
  float height;
} SVGAProtoLayout__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoLayout_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SVGAProtoLayout__storage_, x),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "y",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoLayout_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SVGAProtoLayout__storage_, y),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoLayout_FieldNumber_Width,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SVGAProtoLayout__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoLayout_FieldNumber_Height,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SVGAProtoLayout__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SVGAProtoLayout)
                                   messageName:@"Layout"
                               fileDescription:&SVGAProtoSvgaRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SVGAProtoLayout__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SVGAProtoTransform

@implementation SVGAProtoTransform

@dynamic a;
@dynamic b;
@dynamic c;
@dynamic d;
@dynamic tx;
@dynamic ty;

typedef struct SVGAProtoTransform__storage_ {
  uint32_t _has_storage_[1];
  float a;
  float b;
  float c;
  float d;
  float tx;
  float ty;
} SVGAProtoTransform__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "a",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoTransform_FieldNumber_A,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SVGAProtoTransform__storage_, a),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "b",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoTransform_FieldNumber_B,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SVGAProtoTransform__storage_, b),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "c",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoTransform_FieldNumber_C,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SVGAProtoTransform__storage_, c),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "d",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoTransform_FieldNumber_D,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SVGAProtoTransform__storage_, d),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "tx",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoTransform_FieldNumber_Tx,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SVGAProtoTransform__storage_, tx),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "ty",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoTransform_FieldNumber_Ty,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SVGAProtoTransform__storage_, ty),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SVGAProtoTransform)
                                   messageName:@"Transform"
                               fileDescription:&SVGAProtoSvgaRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SVGAProtoTransform__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SVGAProtoShapeEntity

@implementation SVGAProtoShapeEntity

@dynamic argsOneOfCase;
@dynamic type;
@dynamic shape;
@dynamic rect;
@dynamic ellipse;
@dynamic hasStyles, styles;
@dynamic hasTransform, transform;

typedef struct SVGAProtoShapeEntity__storage_ {
  uint32_t _has_storage_[2];
  SVGAProtoShapeEntity_ShapeType type;
  SVGAProtoShapeEntity_ShapeArgs *shape;
  SVGAProtoShapeEntity_RectArgs *rect;
  SVGAProtoShapeEntity_EllipseArgs *ellipse;
  SVGAProtoShapeEntity_ShapeStyle *styles;
  SVGAProtoTransform *transform;
} SVGAProtoShapeEntity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = SVGAProtoShapeEntity_ShapeType_EnumDescriptor,
        .number = SVGAProtoShapeEntity_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "shape",
        .dataTypeSpecific.clazz = GPBObjCClass(SVGAProtoShapeEntity_ShapeArgs),
        .number = SVGAProtoShapeEntity_FieldNumber_Shape,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity__storage_, shape),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rect",
        .dataTypeSpecific.clazz = GPBObjCClass(SVGAProtoShapeEntity_RectArgs),
        .number = SVGAProtoShapeEntity_FieldNumber_Rect,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity__storage_, rect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ellipse",
        .dataTypeSpecific.clazz = GPBObjCClass(SVGAProtoShapeEntity_EllipseArgs),
        .number = SVGAProtoShapeEntity_FieldNumber_Ellipse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity__storage_, ellipse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "styles",
        .dataTypeSpecific.clazz = GPBObjCClass(SVGAProtoShapeEntity_ShapeStyle),
        .number = SVGAProtoShapeEntity_FieldNumber_Styles,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity__storage_, styles),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transform",
        .dataTypeSpecific.clazz = GPBObjCClass(SVGAProtoTransform),
        .number = SVGAProtoShapeEntity_FieldNumber_Transform,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity__storage_, transform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SVGAProtoShapeEntity)
                                   messageName:@"ShapeEntity"
                               fileDescription:&SVGAProtoSvgaRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SVGAProtoShapeEntity__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    static const char *oneofs[] = {
      "args",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SVGAProtoShapeEntity_Type_RawValue(SVGAProtoShapeEntity *message) {
  GPBDescriptor *descriptor = [SVGAProtoShapeEntity descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SVGAProtoShapeEntity_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSVGAProtoShapeEntity_Type_RawValue(SVGAProtoShapeEntity *message, int32_t value) {
  GPBDescriptor *descriptor = [SVGAProtoShapeEntity descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SVGAProtoShapeEntity_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

void SVGAProtoShapeEntity_ClearArgsOneOfCase(SVGAProtoShapeEntity *message) {
  GPBDescriptor *descriptor = [SVGAProtoShapeEntity descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - SVGAProtoShapeEntity_ShapeArgs

@implementation SVGAProtoShapeEntity_ShapeArgs

@dynamic d;

typedef struct SVGAProtoShapeEntity_ShapeArgs__storage_ {
  uint32_t _has_storage_[1];
  NSString *d;
} SVGAProtoShapeEntity_ShapeArgs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "d",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_ShapeArgs_FieldNumber_D,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_ShapeArgs__storage_, d),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SVGAProtoShapeEntity_ShapeArgs)
                                   messageName:@"ShapeArgs"
                               fileDescription:&SVGAProtoSvgaRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SVGAProtoShapeEntity_ShapeArgs__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SVGAProtoShapeEntity)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SVGAProtoShapeEntity_RectArgs

@implementation SVGAProtoShapeEntity_RectArgs

@dynamic x;
@dynamic y;
@dynamic width;
@dynamic height;
@dynamic cornerRadius;

typedef struct SVGAProtoShapeEntity_RectArgs__storage_ {
  uint32_t _has_storage_[1];
  float x;
  float y;
  float width;
  float height;
  float cornerRadius;
} SVGAProtoShapeEntity_RectArgs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_RectArgs_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_RectArgs__storage_, x),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "y",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_RectArgs_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_RectArgs__storage_, y),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_RectArgs_FieldNumber_Width,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_RectArgs__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_RectArgs_FieldNumber_Height,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_RectArgs__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "cornerRadius",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_RectArgs_FieldNumber_CornerRadius,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_RectArgs__storage_, cornerRadius),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SVGAProtoShapeEntity_RectArgs)
                                   messageName:@"RectArgs"
                               fileDescription:&SVGAProtoSvgaRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SVGAProtoShapeEntity_RectArgs__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\005\014\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SVGAProtoShapeEntity)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SVGAProtoShapeEntity_EllipseArgs

@implementation SVGAProtoShapeEntity_EllipseArgs

@dynamic x;
@dynamic y;
@dynamic radiusX;
@dynamic radiusY;

typedef struct SVGAProtoShapeEntity_EllipseArgs__storage_ {
  uint32_t _has_storage_[1];
  float x;
  float y;
  float radiusX;
  float radiusY;
} SVGAProtoShapeEntity_EllipseArgs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_EllipseArgs_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_EllipseArgs__storage_, x),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "y",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_EllipseArgs_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_EllipseArgs__storage_, y),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "radiusX",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_EllipseArgs_FieldNumber_RadiusX,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_EllipseArgs__storage_, radiusX),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "radiusY",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_EllipseArgs_FieldNumber_RadiusY,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_EllipseArgs__storage_, radiusY),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SVGAProtoShapeEntity_EllipseArgs)
                                   messageName:@"EllipseArgs"
                               fileDescription:&SVGAProtoSvgaRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SVGAProtoShapeEntity_EllipseArgs__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\002\003\007\000\004\007\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SVGAProtoShapeEntity)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SVGAProtoShapeEntity_ShapeStyle

@implementation SVGAProtoShapeEntity_ShapeStyle

@dynamic hasFill, fill;
@dynamic hasStroke, stroke;
@dynamic strokeWidth;
@dynamic lineCap;
@dynamic lineJoin;
@dynamic miterLimit;
@dynamic lineDashI;
@dynamic lineDashIi;
@dynamic lineDashIii;

typedef struct SVGAProtoShapeEntity_ShapeStyle__storage_ {
  uint32_t _has_storage_[1];
  float strokeWidth;
  SVGAProtoShapeEntity_ShapeStyle_LineCap lineCap;
  SVGAProtoShapeEntity_ShapeStyle_LineJoin lineJoin;
  float miterLimit;
  float lineDashI;
  float lineDashIi;
  float lineDashIii;
  SVGAProtoShapeEntity_ShapeStyle_RGBAColor *fill;
  SVGAProtoShapeEntity_ShapeStyle_RGBAColor *stroke;
} SVGAProtoShapeEntity_ShapeStyle__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fill",
        .dataTypeSpecific.clazz = GPBObjCClass(SVGAProtoShapeEntity_ShapeStyle_RGBAColor),
        .number = SVGAProtoShapeEntity_ShapeStyle_FieldNumber_Fill,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_ShapeStyle__storage_, fill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stroke",
        .dataTypeSpecific.clazz = GPBObjCClass(SVGAProtoShapeEntity_ShapeStyle_RGBAColor),
        .number = SVGAProtoShapeEntity_ShapeStyle_FieldNumber_Stroke,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_ShapeStyle__storage_, stroke),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "strokeWidth",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_ShapeStyle_FieldNumber_StrokeWidth,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_ShapeStyle__storage_, strokeWidth),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "lineCap",
        .dataTypeSpecific.enumDescFunc = SVGAProtoShapeEntity_ShapeStyle_LineCap_EnumDescriptor,
        .number = SVGAProtoShapeEntity_ShapeStyle_FieldNumber_LineCap,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_ShapeStyle__storage_, lineCap),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "lineJoin",
        .dataTypeSpecific.enumDescFunc = SVGAProtoShapeEntity_ShapeStyle_LineJoin_EnumDescriptor,
        .number = SVGAProtoShapeEntity_ShapeStyle_FieldNumber_LineJoin,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_ShapeStyle__storage_, lineJoin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "miterLimit",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_ShapeStyle_FieldNumber_MiterLimit,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_ShapeStyle__storage_, miterLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "lineDashI",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_ShapeStyle_FieldNumber_LineDashI,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_ShapeStyle__storage_, lineDashI),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "lineDashIi",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_ShapeStyle_FieldNumber_LineDashIi,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_ShapeStyle__storage_, lineDashIi),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "lineDashIii",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_ShapeStyle_FieldNumber_LineDashIii,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_ShapeStyle__storage_, lineDashIii),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SVGAProtoShapeEntity_ShapeStyle)
                                   messageName:@"ShapeStyle"
                               fileDescription:&SVGAProtoSvgaRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SVGAProtoShapeEntity_ShapeStyle__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\007\003\013\000\004\007\000\005\010\000\006\n\000\007\t\000\010\tA\000\t\tb\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SVGAProtoShapeEntity)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SVGAProtoShapeEntity_ShapeStyle_LineCap_RawValue(SVGAProtoShapeEntity_ShapeStyle *message) {
  GPBDescriptor *descriptor = [SVGAProtoShapeEntity_ShapeStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SVGAProtoShapeEntity_ShapeStyle_FieldNumber_LineCap];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSVGAProtoShapeEntity_ShapeStyle_LineCap_RawValue(SVGAProtoShapeEntity_ShapeStyle *message, int32_t value) {
  GPBDescriptor *descriptor = [SVGAProtoShapeEntity_ShapeStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SVGAProtoShapeEntity_ShapeStyle_FieldNumber_LineCap];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t SVGAProtoShapeEntity_ShapeStyle_LineJoin_RawValue(SVGAProtoShapeEntity_ShapeStyle *message) {
  GPBDescriptor *descriptor = [SVGAProtoShapeEntity_ShapeStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SVGAProtoShapeEntity_ShapeStyle_FieldNumber_LineJoin];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSVGAProtoShapeEntity_ShapeStyle_LineJoin_RawValue(SVGAProtoShapeEntity_ShapeStyle *message, int32_t value) {
  GPBDescriptor *descriptor = [SVGAProtoShapeEntity_ShapeStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SVGAProtoShapeEntity_ShapeStyle_FieldNumber_LineJoin];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SVGAProtoShapeEntity_ShapeStyle_RGBAColor

@implementation SVGAProtoShapeEntity_ShapeStyle_RGBAColor

@dynamic r;
@dynamic g;
@dynamic b;
@dynamic a;

typedef struct SVGAProtoShapeEntity_ShapeStyle_RGBAColor__storage_ {
  uint32_t _has_storage_[1];
  float r;
  float g;
  float b;
  float a;
} SVGAProtoShapeEntity_ShapeStyle_RGBAColor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "r",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_ShapeStyle_RGBAColor_FieldNumber_R,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_ShapeStyle_RGBAColor__storage_, r),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "g",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_ShapeStyle_RGBAColor_FieldNumber_G,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_ShapeStyle_RGBAColor__storage_, g),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "b",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_ShapeStyle_RGBAColor_FieldNumber_B,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_ShapeStyle_RGBAColor__storage_, b),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "a",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoShapeEntity_ShapeStyle_RGBAColor_FieldNumber_A,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SVGAProtoShapeEntity_ShapeStyle_RGBAColor__storage_, a),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SVGAProtoShapeEntity_ShapeStyle_RGBAColor)
                                   messageName:@"RGBAColor"
                               fileDescription:&SVGAProtoSvgaRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SVGAProtoShapeEntity_ShapeStyle_RGBAColor__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    [localDescriptor setupContainingMessageClass:GPBObjCClass(SVGAProtoShapeEntity_ShapeStyle)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SVGAProtoFrameEntity

@implementation SVGAProtoFrameEntity

@dynamic alpha;
@dynamic hasLayout, layout;
@dynamic hasTransform, transform;
@dynamic clipPath;
@dynamic shapesArray, shapesArray_Count;

typedef struct SVGAProtoFrameEntity__storage_ {
  uint32_t _has_storage_[1];
  float alpha;
  SVGAProtoLayout *layout;
  SVGAProtoTransform *transform;
  NSString *clipPath;
  NSMutableArray *shapesArray;
} SVGAProtoFrameEntity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "alpha",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoFrameEntity_FieldNumber_Alpha,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SVGAProtoFrameEntity__storage_, alpha),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "layout",
        .dataTypeSpecific.clazz = GPBObjCClass(SVGAProtoLayout),
        .number = SVGAProtoFrameEntity_FieldNumber_Layout,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SVGAProtoFrameEntity__storage_, layout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transform",
        .dataTypeSpecific.clazz = GPBObjCClass(SVGAProtoTransform),
        .number = SVGAProtoFrameEntity_FieldNumber_Transform,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SVGAProtoFrameEntity__storage_, transform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clipPath",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoFrameEntity_FieldNumber_ClipPath,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SVGAProtoFrameEntity__storage_, clipPath),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shapesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SVGAProtoShapeEntity),
        .number = SVGAProtoFrameEntity_FieldNumber_ShapesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SVGAProtoFrameEntity__storage_, shapesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SVGAProtoFrameEntity)
                                   messageName:@"FrameEntity"
                               fileDescription:&SVGAProtoSvgaRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SVGAProtoFrameEntity__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
      static const char *extraTextFormatInfo =
        "\001\004\010\000";
      [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
    #endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SVGAProtoMovieEntity

@implementation SVGAProtoMovieEntity

@dynamic version;
@dynamic hasParams, params;
@dynamic images, images_Count;
@dynamic spritesArray, spritesArray_Count;
@dynamic audiosArray, audiosArray_Count;

typedef struct SVGAProtoMovieEntity__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
  SVGAProtoMovieParams *params;
  NSMutableDictionary *images;
  NSMutableArray *spritesArray;
  NSMutableArray *audiosArray;
} SVGAProtoMovieEntity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoMovieEntity_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SVGAProtoMovieEntity__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "params",
        .dataTypeSpecific.clazz = GPBObjCClass(SVGAProtoMovieParams),
        .number = SVGAProtoMovieEntity_FieldNumber_Params,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SVGAProtoMovieEntity__storage_, params),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "images",
        .dataTypeSpecific.clazz = Nil,
        .number = SVGAProtoMovieEntity_FieldNumber_Images,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SVGAProtoMovieEntity__storage_, images),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "spritesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SVGAProtoSpriteEntity),
        .number = SVGAProtoMovieEntity_FieldNumber_SpritesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SVGAProtoMovieEntity__storage_, spritesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audiosArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SVGAProtoAudioEntity),
        .number = SVGAProtoMovieEntity_FieldNumber_AudiosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SVGAProtoMovieEntity__storage_, audiosArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(SVGAProtoMovieEntity)
                                   messageName:@"MovieEntity"
                               fileDescription:&SVGAProtoSvgaRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SVGAProtoMovieEntity__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
